---
layout: post
title:  "힌들리-밀너 타입 추론"
date:   2019-04-17 23:52:00 +0900
tags: jekyll update
---

## 힌들리-밀너 타입 추론 Hindley-Milner Type Inference

### 타입 추론이 왜 중요할까? 

> `VeryLongClass veryLongInstance = new VeryLongClass();` 따위의 할당식을 `auto veryLongInstance = new VeryLongClass();`로 줄여주는 거 아닌가? 그냥 rust나 go같은 언어에서 타입을 쓰기 귀찮으면 빼먹어도 컴파일러에서 알아서 타입을 넣어주는게 타입 추론 아닌가? 타자를 적게 쳐도 되는 타입 추론 개꿀~ 나같은 애플리케이션 개발자에게는 대충 그 정도만 알아도 되겠지?

### 아마 꼭 그렇지는 않을 것이다.

타입 시스템, 그 중에서도 **힌들리-밀너 타입 시스템 Hindley-Milner type system**은 이름에서 알 수 있듯이 [논리학자 힌들러가 제시하고](https://www.semanticscholar.org/paper/THE-PRINCIPAL-TYPE-SCHEME-OF-AN-OBJECT-IN-LOGIC/fc64117e5d5ed5947a0c85c55597e4116d6e55c6) [컴퓨터 과학자 밀너가 재발견하여](https://www.sciencedirect.com/science/article/pii/0022000078900144) 70년대에 이미 학문적으로 완성된 내용이다. 왜 이제야 부랴부랴 공부해서 블로그에 이런 글을 쓰냐 하면, 다음의 두 가지 이유 때문이다.

1. 요즘 개발 공부를 하다 보면 자꾸 눈에 밟힌다. 잘난체하면서 힌들리-밀너가 어쩌구 랭크-1이 어쩌구 하는데, 설명해주는 사람은 아무도 없다.
1. 한글로 힌들리-밀너 타입 추론을 검색해보면 많지 않은 결과물이 나오는데, 그중에서 HM 타입 시스템의 알고리즘/수학적 배경을 설명해주는 글이 하나도 없다. PL 이론 전공자들은 인터넷을 안하나? 아니면 이런 건 자기네들끼리만 돌려보나?

이런 이유 때문이다. 그렇다면 다시, 왜 HM 타입 시스템이 자꾸 눈에 밟힐까? 함수형 언어 열풍 때문이다.

함수형 패러다임에서는 *트레잇(=타입클래스)* 등을 활용해 다형성 polymorphism을 획득한다. OOP적으로는 SOLID 원칙의 I, [*인터페이스 분리 원칙*](https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4_%EB%B6%84%EB%A6%AC_%EC%9B%90%EC%B9%99)이다.

다형성은 결국, 함수를 포함한 변수가 여러 개의 타입을 갖는 것이다. 제네릭 등을 사용해 함수의 추상화, 다형성을 구현하려 한다고 하자. 컴파일러 속 타입 체커는 이걸 어떻게 처리할까? 이렇게 타입을 통해 다형성을 구현할 경우(*rank-k polymorphism*), 타입 체크 단계에서는 타입의 단순 비교 이상의 복잡한 로직이 필요해진다. C++이나 자바 컴파일러에는 없는 무언가가 필요하다.

이런 경우, 타입 체크 시스템은 타입을 정확히 특정해 낼 수 없더라도 유효한 연산인지를 판단할 수 있어야 하므로 타입 정보를 문맥에서 유추해 낼 필요가 있다. 말하자면 소스코드의 타입 정보만 빼서 전처리를 돌리는 셈이다. 한 표현식 expression의 타입을 유추하기 위해서 (당연히) 논리학의 힘을 빌린다.

나는 (아직은) 컴파일러나 전처리기같은 물건의 개발에는 관심이 없고 순수 수학도 흥미가 없어서 알고리즘이나 증명 같은 것은 자세히 읽지도 않았다. 이 글에서는 HM 타입 추론에서 사용하는 6개의 논리 규칙에 대해 설명하려고 한다.